'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var EventEmmiter = _interopDefault(require('eventemitter3'));

class ModuleAlreadyExistsError extends Error {
    constructor() {
        super('Module already exists.');
        Object.setPrototypeOf(this, ModuleAlreadyExistsError.prototype);
        this.name = 'ModuleAlreadyExistsError';
    }
}
class ModuleNotFoundError extends Error {
    constructor() {
        super('Module not found.');
        Object.setPrototypeOf(this, ModuleNotFoundError.prototype);
        this.name = 'ModuleNotFoundError';
    }
}

(function (ModuleInitializerEvents) {
    ModuleInitializerEvents["load"] = "load";
    ModuleInitializerEvents["remove"] = "remove";
    ModuleInitializerEvents["error"] = "error";
})(exports.ModuleInitializerEvents || (exports.ModuleInitializerEvents = {}));
class ModuleInitializer extends EventEmmiter {
    constructor() {
        super(...arguments);
        this.initFns = new Map();
        this.initPromises = new Map();
        this.modules = new Map();
        this.addModule = (name, initFn) => {
            if (this.initFns.has(name)) {
                const error = new ModuleAlreadyExistsError();
                this.emit(exports.ModuleInitializerEvents.error, error, name, initFn);
                throw error;
            }
            this.loadModulesPromise = undefined;
            this.initFns.set(name, initFn);
        };
        this.getModule = (name) => {
            if (!this.modules.has(name)) {
                const error = new ModuleNotFoundError();
                this.emit(exports.ModuleInitializerEvents.error, error, name);
                throw error;
            }
            return this.modules.get(name);
        };
        this.hasModule = (name) => this.modules.has(name);
        this.setModule = (name, module) => {
            this.modules.set(name, module);
            this.emit(exports.ModuleInitializerEvents.load, name, module);
        };
        this.removeModule = (name) => {
            this.initFns.delete(name);
            this.initPromises.delete(name);
            if (this.modules.has(name)) {
                const module = this.modules.get(name);
                this.modules.delete(name);
                this.emit(exports.ModuleInitializerEvents.remove, name, module);
            }
        };
        this.loadModule = (name, ...args) => {
            if (!this.initFns.has(name)) {
                const error = new ModuleNotFoundError();
                this.emit(exports.ModuleInitializerEvents.error, error, name, ...args);
                throw error;
            }
            if (this.initPromises.has(name)) {
                return this.initPromises.get(name);
            }
            const initPromise = this.initFns.get(name)(...args).then(module => {
                this.modules.set(name, module);
                this.emit(exports.ModuleInitializerEvents.load, name, module, ...args);
                return Promise.resolve();
            });
            this.initPromises.set(name, initPromise);
            return initPromise;
        };
        this.loadModules = (args) => {
            if (this.loadModulesPromise) {
                return this.loadModulesPromise;
            }
            const myArgs = args || {};
            const names = Array.from(this.initFns.keys());
            const loadModules = names.map(name => {
                if (myArgs[name]) {
                    return this.loadModule(name, ...myArgs[name]);
                }
                return this.loadModule(name);
            });
            this.loadModulesPromise = Promise.all(loadModules).then(() => Promise.resolve());
            return this.loadModulesPromise;
        };
    }
}

exports.ModuleAlreadyExistsError = ModuleAlreadyExistsError;
exports.ModuleInitializer = ModuleInitializer;
exports.ModuleNotFoundError = ModuleNotFoundError;
