/// <reference types="node" />
import { HashAlgorithm } from './HashAlgorithm';
import { KeyPairType } from './KeyPairType';
import { ICrypto, NodeBuffer as BufferType, Data, IGroupSession } from './types';
import { VirgilPrivateKey } from './VirgilPrivateKey';
import { VirgilPublicKey } from './VirgilPublicKey';
import { VirgilStreamCipher } from './VirgilStreamCipher';
import { VirgilStreamDecipher } from './VirgilStreamDecipher';
import { VirgilStreamDecryptAndVerify } from './VirgilStreamDecryptAndVerify';
import { VirgilStreamSignAndEncrypt } from './VirgilStreamSignAndEncrypt';
import { VirgilStreamSigner } from './VirgilStreamSigner';
import { VirgilStreamVerifier } from './VirgilStreamVerifier';
export interface VirgilCryptoOptions {
    useSha256Identifiers?: boolean;
    defaultKeyPairType?: KeyPairType;
}
export declare class VirgilCrypto implements ICrypto {
    readonly hashAlgorithm: typeof HashAlgorithm;
    readonly keyPairType: typeof KeyPairType;
    readonly useSha256Identifiers: boolean;
    readonly defaultKeyPairType: KeyPairType;
    constructor(options?: VirgilCryptoOptions);
    generateKeys(type?: KeyPairType[keyof KeyPairType]): {
        privateKey: VirgilPrivateKey;
        publicKey: VirgilPublicKey;
    };
    generateKeysFromKeyMaterial(keyMaterial: Data, type?: KeyPairType[keyof KeyPairType]): {
        privateKey: VirgilPrivateKey;
        publicKey: VirgilPublicKey;
    };
    importPrivateKey(rawPrivateKey: Data): VirgilPrivateKey;
    exportPrivateKey(privateKey: VirgilPrivateKey): Buffer;
    importPublicKey(rawPublicKey: Data): VirgilPublicKey;
    exportPublicKey(publicKey: VirgilPublicKey): Buffer;
    encrypt(data: Data, publicKey: VirgilPublicKey, enablePadding?: boolean): BufferType;
    encrypt(data: Data, publicKeys: VirgilPublicKey[], enablePadding?: boolean): BufferType;
    decrypt(encryptedData: Data, privateKey: VirgilPrivateKey): Buffer;
    calculateHash(data: Data, algorithm?: HashAlgorithm[keyof HashAlgorithm]): Buffer;
    extractPublicKey(privateKey: VirgilPrivateKey): VirgilPublicKey;
    calculateSignature(data: Data, privateKey: VirgilPrivateKey): Buffer;
    verifySignature(data: Data, signature: Data, publicKey: VirgilPublicKey): boolean;
    signAndEncrypt(data: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey, enablePadding?: boolean): BufferType;
    signAndEncrypt(data: Data, privateKey: VirgilPrivateKey, publicKeys: VirgilPublicKey[], enablePadding?: boolean): BufferType;
    signThenEncrypt(data: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey, enablePadding?: boolean): BufferType;
    signThenEncrypt(data: Data, privateKey: VirgilPrivateKey, publicKeys: VirgilPublicKey[], enablePadding?: boolean): BufferType;
    decryptAndVerify(encryptedData: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey): BufferType;
    decryptAndVerify(encryptedData: Data, privateKey: VirgilPrivateKey, publicKeys: VirgilPublicKey[]): BufferType;
    decryptThenVerify(encryptedData: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey): BufferType;
    decryptThenVerify(encryptedData: Data, privateKey: VirgilPrivateKey, publicKeys: VirgilPublicKey[]): BufferType;
    getRandomBytes(length: number): Buffer;
    signThenEncryptDetached(data: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey, enablePadding?: boolean): {
        encryptedData: BufferType;
        metadata: BufferType;
    };
    signThenEncryptDetached(data: Data, privateKey: VirgilPrivateKey, publicKeys: VirgilPublicKey[], enablePadding?: boolean): {
        encryptedData: BufferType;
        metadata: BufferType;
    };
    decryptThenVerifyDetached(encryptedData: Data, metadata: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey): BufferType;
    decryptThenVerifyDetached(encryptedData: Data, metadata: Data, privateKey: VirgilPrivateKey, publicKeys: VirgilPublicKey[]): BufferType;
    createStreamCipher(publicKey: VirgilPublicKey, signature?: Data): VirgilStreamCipher;
    createStreamCipher(publicKeys: VirgilPublicKey[], signature?: Data): VirgilStreamCipher;
    createStreamDecipher(privateKey: VirgilPrivateKey): VirgilStreamDecipher;
    createStreamSignAndEncrypt(privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey, enablePadding?: boolean): VirgilStreamSignAndEncrypt;
    createStreamSignAndEncrypt(privateKey: VirgilPrivateKey, publicKeys: VirgilPublicKey[], enablePadding?: boolean): VirgilStreamSignAndEncrypt;
    createStreamDecryptAndVerify(): VirgilStreamDecryptAndVerify;
    createStreamSigner(): VirgilStreamSigner;
    createStreamVerifier(signature: Data): VirgilStreamVerifier;
    generateGroupSession(groupId: Data): IGroupSession;
    importGroupSession(epochMessages: Data[]): IGroupSession;
    calculateGroupSessionId(groupId: Data): string;
    private createHash;
    private calculateKeyPairIdentifier;
    private generateKeyPair;
    private _signAndEncrypt;
    private _signThenEncrypt;
    private _decryptAndVerify;
    private _decryptThenVerify;
}
